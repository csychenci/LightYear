---
title: 类型基础
date: 2021-03-08 23:39:45
categories: TypeScript
order: 2
tags:
  - JavaScript超集
  - TypeScript
---

## 类型检查机制
---
1. 类型的作用
- 通常是指基础类型(*number*、*string*、*boolean*等)与复合类型(*Object*、*Function*等)，它们是 **编程语言提供的对不同内容的抽象**
- 其中，**不同类型变量占据的内存大小不同**，给变量声明不同的类型就代表了会 **占据不同的内存空间**。另一个，**不同类型变量可做的操作不同**，例如不能对 boolean 类型执行 number 类型才能做的加减乘除操作，某些复合类型中不同类型的对象可用的方法不同，变量的类型不同代表可以对该变量做的操作就不同

2. 类型安全
- 也就是说，类型与要对它所做的操作需要 **匹配** 才行，这就是为什么需要类型检查，它是为了保证 **类型安全**
- **如果能保证对某种类型只做该类型允许的操作，这就叫做类型安全**。例如你调用一个对象上不存在的方法，这就是类型不安全；你对 boolean 类型做加减乘除操作，这也是类型不安全

3. 什么时候做类型检查
- 类型检查可以运行时做，也可以运行之前的编译期做。前者叫做动态类型检查，后者叫做静态类型检查
- 动态类型检查在源码中 **不保留类型信息**，对某个变量赋值、做不同的操作都是允许的，比较灵活。但它也埋下了类型不安全的隐患，包括但不限于对 boolean 做加减乘除、调用对象不存在的方法等，这些错误都只能在运行时才能检查出来
- 而静态类型检查会在源码中保留类型信息，声明变量要指定类型，对变量做的操作需要和类型匹配，会有专门的编译器在编译期间做检查。除了不够灵活（需要考虑类型是否匹配、是否需要做转换等），但消除了类型不安全的隐患

4. 适用场景
- 动态类型由于它的灵活性，适合简单的场景。但对于大型项目却不合适，类型不安全的情况下存在的隐患太多了；虽然静态类型会增加写代码的成本，但却能很好的保证代码的健壮性，减少出问题的概率。因此，大型项目注定会用静态类型语言开发
---
## 语言特性
---

1. 强类型与弱类型
- 在强类型语言中，当一个对象从调用者传到被调用函数时，其类型必须与被调用函数中声明的类型兼容，强类型语言 *不允许改变变量的类型*，除非进行强制类型转换
```java
// java
class C {
  public static void main(String[] args) {
    int x = 1;
    boolean y = true;
    x = y;
    // 报错，类型不兼容，不能将boolean转化为int
    System.out.println(x)
  }
}
```
- 弱类型语言中，变量可以被赋予 *不同的数据类型*
2. 动态类型与静态类型
- 静态类型语言会在 **编译阶段** 就确定所有变量的类型，动态类型语言在 **执行阶段** 才能确定所有变量的类型
```js
// 只有执行的时候才能根据传入的数据的类型确定参数的类型
function add(a, b){
  return a + b
}
```
```c++
class C{
  public:
    int x;
    int y;
}

// 编译的时候就能确定类型
int add(C a, C b){
  return a + b
}
```
---

## 其他类型机制

---
1. 类型推断
- 类型注解：作用相当于强类型语言中的类型声明，可以对变量起到约束的作用。Ts 允许我们给变量显式设置一个类型。但它也有一个推断机制，也就是说 ts 会根据为变量赋的值自动给该变量设置一个类型

```ts
let age: number = 20;
let name: string = 'Mary';
let boy: boolean = true;
```

```ts
let age = 20;
let name = 'Mary';
let boy = true;
```

- 以上代码 `ts` 仍然知道变量的类型，因此不需要显式地去设置。那么，什么时候需要显式地设置类型呢?

```ts
let home: string;
let idcard: number;
let cardlist = [1234, 2345, 4567, 7890];
idcard = cardlist[1];
```

- 当声明了一个变量却没有设置初始值时，我们应当给其设置一个类型。否则，该变量的类型会被自动设置为 `any`，意思是可以接收任何值，就像使用 js 变量一样

- _number_ 与 _bigint_ 都表示数字，但此两种类型不兼容，可能会导致一个类型不兼容的错误

```ts
let bignum: bigint =BigInt(1);
let num: number = 100;

bignum = num;
// Type 'number' is not assignable to type 'bigint'.ts(2322)
```

- _typescript_ 编译器将通过对比检测变量接收值的类型与我们显示注解的类型，从而检测类型是否存在错误。_ts_ 会在没有明确进行类型注解时根据上下文推测出一个类型，这就是类型推论

```ts
/** 
 * 参数x的类型从默认值推断为number
 * 而返回值的类型也根据x的推断为number
*/

const println = (x = 1) => {
  return x
}
/** 
 * const println: (x?: number) => number
*/
```

- 还有一种是 **上下文类型推断**，在上面的推断中，都是从右向左推断的，也就是根据表达式右侧的值的类型推断出表达式左侧的值的类型。而上下文类型推断是反过来的
```ts
document.onmousemove = (event) => {
  
}

/** 
 * event的类型根据节点绑定的事件的类型进行推断
 * 此处绑定的是一个鼠标移动事件，因此 event 的类型为 MouseEvent
 * (parameter) event: MouseEvent
 */

document.onkeydown = (event) => {
  
}

/** 
 * 此处绑定的是一个键盘按下事件，因此 event 的类型为 KeyboardEvent
 * (parameter) event: KeyboardEvent
 */
```

2. 类型兼容
- 当一个类型(目标类型) x 可以被赋值给另一个类型(源类型) y 时，我们就可以说类型 x 兼容类型 y

```ts
let str: string = 'a';

let unknown_type:unknown;

unknown_type = str;
```

- 在上面的示例中，我们就可以说，string 是兼容 unknown 的(类型层面)。而在接口中也存在类型兼容的情况，如果一个接口的形状符合另一个接口的形状，也就是成员少的兼容成员多的，或者说接口 B 是接口 A 的子集

```ts
interface A{
  name:string;
  age:number
}

interface B{
  name:string;
  age:number;
  id:number | string;
}

let a:A = {
  name:"a",
  age:18
}

let b:B = {
  name:"b",
  age:25,
  id:'cead15-gur5'
}

a = b;
// ok

b = a;
// ts error

/**
 * A接口成员较少，B接口成员较多。而当将符合B接口形状的对象赋值给符合A接口形状的对象时，
 * B接口中多出来的成员并不会影响与A接口有关的操作，因此是类型安全的
 * 反过来，A接口中缺少B接口中的某些成员，对符合A接口的对象操作时，
 * 可能会访问或者操作其中不存在的成员，因此类型就是不安全的
 */
```

- 在函数中类型兼容需要满足三个条件，第一个是参数的个数只能少于或者等于。其中涉及到必选参数、可选参数、剩余参数的类型兼容问题

```ts
let x = (a:number,b:number) => {}
let y = (a?:number,b?:number) => {}
let z = (...rest: number[]) => { }


x = y;
x = z;
// ok

y = x;
y = z;
// ts error

z = x;
z = y;
// ok

/** 
 * 可选参数不兼容剩余参数和固定参数
 * 固定参数兼容剩余参数和可选参数
 * 剩余参数可以兼容固定参数和可选参数
 * 通过以上规则得出：固定参数和剩余参数是可选参数的子集，固定参数是剩余参数的子集
*/
```

- 第二个条件是参数类型必须是兼容的。其中参数多的兼容参数少的
- 第三个条件是返回值类型是兼容的。这里面是返回值类型的成员少的兼容返回值类型的成员多的

3. 类型保护机制
- ts 能够在 **特定的区块中** 保证变量属于某种确定的类型，在此区块中可以放心地引用此类型的属性或者调用此类型的方法

|创建区块的方式|
|---|
|instanceof|
|in|
|typeof|
|自定义函数判断|