## 内存空间
---
1. 内存与函数
- 函数在其生命周期内，分为两个阶段：一个是函数体，它是声明时会被存储于内存中，一般是持久存在的(页面关闭才会得到释放)；另一个是执行上下文，它是函数执行时才会生成的，它也需要占用浏览器的内存，不过它会在函数执行完成后释放掉(执行上下文被销毁)
- 当一个应用被启动时，os 需要给它分配内存空间，而这个内存空间一定是连续的(比如0-100,地址是连续的)

2. 栈内存与堆内存
- 浏览器中的内存空间主要分为两块，一块是栈内存，它主要用于管理函数调用关系/执行顺序；另一块是堆内存，它可以存储任意的数据、引用等

![](./img//66ae372dec45d95fb9c3764c0194623b.png)

- 并且规定栈内存从内存空间的地址高位开始使用，它使用的内存单元是有限制的，不允许超出这个限制(爆栈、内存(栈)溢出)；那么除了限制之外的栈内存，其余的空间就是堆内存可以使用的，它从地址地位开始使用

3. 内存溢出与内存泄漏
- 栈内存不允许超出它的上限去使用额外的内存空间，一旦超出，就会出现内存溢出，因此这个概念一般是针对栈内存的，因为它可使用的内存空间比较小
- 内存泄漏指的是某一段分配的内存空间，因为某种情况无法被管理到了。主要是这段内存空间不可达了(也就是失去了引用)，另一个就是失去了引用也没被标记
- 这种情况下会导致垃圾回收机制无法识别它是否是一个垃圾，这段内存就会变成一个无法使用的状态，这种就叫泄露

4. 垃圾回收机制
- 当一个变量改变指向时，这意味着浏览器会为它指向的数据创建一个内存空间，那为什么不能覆盖到原空间呢?因为这样会带来内存管理成本上的问题，这就说明了为什么基本数据类型是不可变的

- 当我们声明一个对象并且使用它，在我们不再使用时，我们可以将它的内存释放

```js
let obj = {
  name:'xiaoming',
}

/** 操作对象 */
obj.age = 18;

/** 释放内存 */
obj = null
```

- 但并不是做了这样一个操作后并不会马上被回收，它此时的状态 **还是留在内存中，不过是等着被回收**
- 垃圾回收机制会定期的从一个全局对象开始遍历，清除哪些失去引用等待回收的内存