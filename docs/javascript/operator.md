---
title: 运算符
date: 2021-03-02 02:25:12
sidemenu: true
toc: 'content'
order: 7
author: chencicsy
categories: JavaScript
tags:
  - 位运算
  - 逻辑运算符
  - 比较运算符
  - 隐式类型转换
description:
---



## 运算符

---

1. 比较运算符

| 比较运算符 |   描述   |
| -------- | ------ |
|     ==     |   相等   |
|    ===     |   全等   |
|     !=     |   不等   |
|     >      |   大于   |
|     <      |   小于   |
|     >=     | 大于等于 |
|     <=     | 小于等于 |

- `===` 不会自动转换数据类型，如果数据类型一致，再比较数据是否一致;如果数据类型不一致，返回 `false`

2. 空值合并运算符
- `??` 代表空值合并运算符，`a ?? b` 表示为，如果第一个参数不是 ` null/undefined`，则 `??` 返回左操作数。否则，返回右操作数
- 它可以用于给一个未定义的变量提供默认值，但需注意的是，它的 `优先级` 仅高于 `=/?`，并且不能与 `|| &&` 一起使用
- 该运算符与 `||` 有着许多相似之处，但 `||` 无法区分 `false`、`0`、`空字符串`、`null`、`undefined`。`||` 会返回第一个 `真值`，而 `??` 会返回第一个已定义的值

```js
let res;
let count = res ?? 10;
// 10
```

3. 逻辑运算符

| 逻辑运算符 | 描述 |
| -------- | --- |
|     &&     |  与  |
|    \|\|    |  或  |
|     !      |  非  |

- `逻辑非` 运算符会将操作数转换为一个 `布尔值`，然后对其进行取反。在转换 `布尔值` 的过程中，会隐式调用 `Boolean` 进行转换

| 数值类型  | 转换为布尔值                                                       |
| --------- | ------------------------------------------------------------------ |
| undefined | false                                                              |
| null      | false                                                              |
| boolean   | `true` 是 true，`false` 是 false                                   |
| number    | +0、-0 及 NaN 都是 false，其他都为 true                            |
| string    | 长度为 0 的字符串/空字符串为 false，长度大于等于 1 的字符串为 true |
| symbol    | true                                                               |
| object    | 所有的对象都是 true                                                |

- 在 `与`、`或` 关系中，左右侧值为真假值的不同表现

```js
// 1. 左侧值为真值，右侧值为假值

// 与
'1234' && 0; // 0

// 或
'1234' || 0; // '1234'
```

```js
// 2. 左侧值为真值，右侧值为真值

// 与
'1234' && 12; // 12

// 或
'1234' || 12; // '1234'
```

```js
// 3. 左侧值为假值，右侧值为真值

// 与
NaN && 12; // NaN

// 或
NaN || 12; // 12
```

```js
// 4. 左侧值为假值，右侧值为假值

// 与
0 && ''; // 0

// 或
0 || ''; // ''
```

- 可以发现，从左向右结合中，`逻辑与` 关系中，只有左侧值为 `真值` 时，运算才会向右结合；否则，直接返回 `假值`。而 `逻辑或` 关系中，只有左侧值为 `假值` 时，运算才会向右结合；否则，直接返回 `真值`，若均为 `假值`，则返回最右边的 `假值`

4. 原码、反码、补码

- 计算机保存原始的数字，是没有正和负的数字，叫做 `无符号数字`。因此，在内存中分配 4 位 bit 去存储无符号数字，是下面这种情况

| 十进制 | 二进制(4 位) |
| :----: | :----------: |
|   0    |     0000     |
|   1    |     0001     |
|   2    |     0010     |
|   3    |     0011     |
|   4    |     0100     |

- 在计算机内，有符号数有三种表示法：`原码`、`反码`、`补码`，属于数值存储的方式。正数的 `原码`、`反码`、`补码` 是一样的，而实际上 `反码` 和 `补码` 是用来处理负数用的。负数的 `反码` 中，符号位置不变，其余位置相反。而负数的 `补码` 则是在 `反码` 的基础上补充一个新的代码，即 +1，同时多出来的最高位会被丢掉，它是为了解决 -0 存在的问题

| 十进制 | 原码 | 反码 | 补码 |
| :----: | :--: | :--: | :--: |
|   0    | 0000 | 0000 | 0000 |
|   -0   | 1000 | 1111 | 0000 |
|   2    | 0010 | 0010 | 0010 |
|   -3   | 1011 | 1100 | 1101 |
|   3    | 0011 | 0011 | 0011 |

5. 位运算

- 位运算就是对 `二进制` 数执行计算，是整数的逐位运算
- `逻辑位运算符` 与 `逻辑运算符` 的运算方式是相同的，但是针对的对象不同。`逻辑位运算符` 针对的是 `二进制` 的整数值，而 `逻辑运算符` 针对的是 `非二进制` 的值

| 位运算符 |    表述    |     名称     | 描述                                                  |
| :------: | :--------: | :----------: | :---------------------------------------------------- |
|    &     |    位与    |     AND      | 如果两位都是 1,则设置结果位为 1                         |
|    \|    |    位或    |      OR      | 如果两位之一为 1,则设置结果位为 1                       |
|    ~     |    位非    |     NOT      | 反转所有位                                            |
|    ^     |   位异或   |     XOR      | 如果两位只有一位为 1,则设置结果位为 1                   |
|    <<    |    左移    | 零填充左位移 | 通过从右推入零向左位移,并使最左边的位脱落             |
|    >>    |    右移    | 有符号右位移 | 通过从左推入最左位的拷贝来向右位移,并使最右边的位脱落 |
|   >>>    | 无符号右移 | 零填充右位移 | 通过从左推入零来向右位移,并使最右边的位脱落           |

- `&(位与)` 运算符用于对两个 `二进制` 操作数进行比较，只有两位都是 1 时才返回 1，否则返回 0

| 第一位的值 | 第二位的值 | 结果 |
| :--------- | :--------- | :--- |
| 1          | 1          | 1    |
| 1          | 0          | 0    |
| 0          | 1          | 0    |
| 0          | 0          | 0    |

```js
1 & 1; // 0001 & 0001 == 0001
1 & 0; // 0001 & 0000 == 0000
0 & 1; // 0000 & 0001 == 0000
0 & 0; // 0000 & 0000 == 0000
```

```js
10 & 4; // 0
// 0000 0000 0000 0000 0000 0000 1010 &  0000 0000 0000 0000 0000 0000 0100;

// 0000 0000 0000 0000 0000 0000 0000 == 0
```

- `|(位或)` 运算符用于对两个 `二进制` 操作数逐位进行比较，只要有一位为 1 就返回 1，否则返回 0

| 第一位的值 | 第二位的值 | 结果 |
| :--------- | :--------- | :--- |
| 1          | 1          | 1    |
| 1          | 0          | 1    |
| 0          | 1          | 1    |
| 0          | 0          | 0    |

```js
1 | 1; // 0001 | 0001 == 0001
1 | 0; // 0001 | 0000 == 0001
0 | 1; // 0000 | 0001 == 0001
0 | 0; // 0000 | 0000 == 0000
```

```js
16 | 8; // 24
// 0000 0000 0000 0000 0000 0001 0000 |  0000 0000 0000 0000 0000 0000 1000;

// 0000 0000 0000 0000 0000 0001 1000 == 24
```

- `^(位异或)` 运算符用于对两个 `二进制` 操作数逐位进行比较，如果两个位值不相同，则异或结果为 1。如果两个位值相同，异或结果为 0

| 第一位的值 | 第二位的值 | 结果 |
| :--------- | :--------- | :--- |
| 1          | 1          | 0    |
| 1          | 0          | 1    |
| 0          | 1          | 1    |
| 0          | 0          | 0    |

```js
1 ^ 1; // 0001 ^ 0001 == 0000
1 ^ 0; // 0001 ^ 0000 == 0001
0 ^ 1; // 0000 ^ 0001 == 0001
0 ^ 0; // 0000 ^ 0000 == 0000
```

```js
25 ^ 12; // 21
// 0000 0000 0000 0000 0000 0001 1001 ^  0000 0000 0000 0000 0000 0000 1100;

// 0000 0000 0000 0000 0000 0001 0101 == 21
```

- `~(位非)`运算符用于对一个 `二进制` 操作数逐位进行取反操作。一、先把运算数转换成 32 位数字，超过 32 位数字将丢弃最高有效位，二、把二进制数进行取反操作，即 0 变成 1，1 变成 0，三、如果原数是一个正数，则将该二进制数进行取反(符号位不变)，将取反后的数据进行 `+1` 操作；如果该原数是一个负数，则将该二进制数进行 `+1` 操作(符号位不变)，再将结果进行取反。对任一数值 `x` 进行按位非操作的结果为 `-(x+1)`

| 位值 | NOT |
| :--- | :-- |
| 1    | 0   |
| 0    | 1   |

```js
~ -12
//1. 先将-12转化为32位二进制数
1000 0000 0000 0000 0000 0000 0000 1100

// 2. 进行取反操作
0111 1111 1111 1111 1111 1111 1111 0011

// 3. 原数是一个负数，因此，需要先进行+1操作，符号位不变
0111 1111 1111 1111 1111 1111 1111 0100

// 4. 再将结果进行按位取反，符号位不变
0000 0000 0000 0000 0000 0000 0000 1011

// 5. 再将32位二进制数转化为十进制数
11

// 结果为11
```

```js
~ 12
// 1. 先将12转化为32位二进制数
0000 0000 0000 0000 0000 0000 0000 1100

// 2. 对二进制数进行取反操作
1111 1111 1111 1111 1111 1111 1111 0011

// 3. 原数是一个正数，因此，需要再次进行取反操作，符号位不变
1000 0000 0000 0000 0000 0000 0000 1100

// 4. 再将结果进行+1操作
1000 0000 0000 0000 0000 0000 0000 1101

// 5. 再将32位二进制数转化为十进制数
-13

// 结果为-13
```

```js
~-1; // 0
~0; // -1
~1; // -2
~2; // -3
```

6. 移位运算

- `移位运算` 就是对 `二进制` 进行有规律低移位
- `<<` 运算符执行左移位运算。在此过程中，符号位始终保持不变；如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃

```js
12 << 5; // 将数字12左移位5位，返回结果为 384
// 0000 0000 0000 0000 0000 0000 0000 1100

// 0000 0000 0000 0000 0000 0001 1000 0000 == 384
```

- `>>` 运算符执行有符号右移位运算。在此过程中，将 32 位数字中的有效位整体右移，再使用符号位的值填充空位；移动过程中超出的值，将被自动丢弃

```js
1200 >> 5; // 将数字1200右移位5位，返回结果为 37
// 0000 0000 0000 0000 0000 0100 1011 0000

// 0000 0000 0000 0000 0000 0000 0010 0101 == 37
```

```js
/**
 * 将数字-1000右移位8位，返回结果为 -4
 */
-1000 >> 8;
/**
 * 1. 先获取-1000的原码表示形式 1000 0000 0000 0000 0000 0011 1110 1000
 * 2. 将原码转化为反码 1111 1111 1111 1111 1111 1100 0001 0111
 * 3. 再将反码转化为补码 1111 1111 1111 1111 1111 1100 0001 1000
 * 4. 在补码 1111 1111 1111 1111 1111 1100 0001 1000 的基础上进行移位运算
 * 5. 再将补码转化为原码(在补码基础上 - 1 变成反码，再在反码基础上取反(符号位不变))
 * 1111 1111 1111 1111 1111 1111 1111 1100 --> 1111 1111 1111 1111 1111 1111 1111 1011 --> 1000 0000 0000 0000 0000 0000 0000 0100 --> -4
 */
```

- `>>>` 运算符执行无符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的；对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理

```js
-1000 >> 8; // 将数字-1000右移位8位，返回结果为 -4
// 1111 1111 1111 1111 1111 1100 0001 1000

/**
 * 1. 仍然是要将负数的原码转化为反码
 * 2. 再将反码转化为补码，在补码的基础上向右移位
 * 3. 移位过程中使得右边的位脱落，左边空出来的位置使用 0 填充
 */
-1000 >>> 8;

// 0000 0000 1111 1111 1111 1111 1111 1100 == 16777212

1000 >>> 8; // 将数字1000右移位8位，返回结果为 3
// 0000 0000 0000 0000 0000 0001 1111 0100

// 0000 0000 0000 0000 0000 0000 0000 0011 == 3

1000 >> 8; // 将数字1000右移位8位，返回结果为 3
// 0000 0000 0000 0000 0000 0001 1111 0100

// 0000 0000 0000 0000 0000 0000 0000 0011 == 3
```

7. 相等运算符

- 相等运算符有两种：`==` 和 `===`。使用 `==` 运算符比较时，类型相同时，会比较 `内存地址` 和 `值` 是否一样
- 对于 `原始数据类型` 来说，类型一样时，会直接比较值是否一样；类型不一样时，类型不同时会应用 `隐式类型转换`。转换规则如下
- 对于 `对象` 来说，如果两个操作数都是对象，则比较它们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 `true`；否则，返回 `false`。如果两个操作数不都是对象，则应用 `隐式类型转换`。转换规则如下

| 类型 x        | 类型 y        | 结果                |
| ------------- | ------------- | ------------------- |
| null          | undefined     | true                |
| undefined     | null          | true                |
| number        | string        | x == toNumber(y)    |
| string        | number        | y == toNumber(x)    |
| boolean       | 任何类型      | toNumber(x) == y    |
| 任何类型      | boolean       | x == toNumber(y)    |
| number/string | object        | x == toPrimitive(y) |
| object        | number/string | toPrimitive(x) == y |

- 以上情况之外的直接返回 `false`。而 `toNumber` 和 `toPrimitive` 是内部的，它们根据以下情况估值

| 值类型 | 结果 |
| --- | --- |
| undefined | NaN |
| null | +0 |
| boolean | 如果是 true，返回 1;如果是 false，返回 0 |
| number | 数值对应的值 |
| object | 如果对象的 `valueOf` 方法的结果是原始值，则返回这个原始值；如果对象的 `toString` 方法返回原始值，则返回这个值；否则返回一个错误 |

```js
let b1 = new Boolean(false);
b1.valueOf(); // false

let n1 = new Number(256);
n1.valueOf(); // 256

let obj1 = { name: 'abc' };
obj1.toString(); // "[object Object]"

let arr1 = [
  1,
  2,
  3,
  function () {
    console.log(1);
  },
];
arr1.toString(); // "1,2,3,function (){console.log(1)}"

let obj2 = {};
obj2.toString(); // "[object Object]"

let arr2 = [];
arr2.toString(); // ''
```

```js
let obj = {
  value: 1,
  [Symbol.toPrimitive]() {
    return this.value;
  },
};

let obj1 = {
  value: 1,
  valueOf() {
    return this.value;
  },
};

let obj2 = {
  value: 1,
  toString() {
    return this.value;
  },
};

let obj3 = {
  value: 1,
};

obj == 1; // ture
obj1 == 1; // ture
obj2 == 1; // true
obj3 == 1; // false
```

- 对于 `===` 来说，先比较两个值的类型是否相同，如果不同即返回 `false`；否则，会根据以下情况判断

| 类型 x  | 值                       | 结果 |
| ------- | ------------------------ | ---- |
| number  | 两个值相同（但不为 NaN） | true |
| string  | 两个相同的字符           | true |
| boolean | 两个值都是 true 或 false | true |
| object  | 两个变量引用同一个对象   | true |

---
## 练习题
---
1. 如何使 _x==1&&x==2&&x==3_ 成立

- 利用 _==_ 会隐式类型转换，通过重写对象的 _valueOf_ 或 _toString_ 或 _toPrimitive_ 方法进行操作

```js
let obj = {
  value: 1,
  valueOf() {
    return this.value++;
  },
};

obj == 1 && obj == 2 && obj == 3; // true
```

```js
let obj = {
  value: [3, 2, 1],
  toString() {
    return this.value.pop();
  },
};

obj == 1 && obj == 2 && obj == 3; // true
```

```js
let obj = {
  reg: /\d/g,
  [Symbol.toPrimitive]() {
    return this.reg.exec(123)[0];
  },
};

obj == 1 && obj == 2 && obj == 3; // true
```
