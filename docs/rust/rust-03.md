---
title: rust编程概念(一)
date: 2023-03-31 03:18:44
categories: Rust
order: 4
tags:
  - Rust
---

## 变量与可变性
---
1. 声明变量
- 使用 `let` 关键字声明一个变量，默认情况下变量是不可变的，一旦这个变量被绑定到一个值后，它就不可被赋值了，否则编译的时候就会报错
```rs
let sum = 1;

sum = 2;
// cannot assign twice to immutable variable
```
- 如果需要让变量可变的话，可以在声明变量的时候，在变量前面加上 mut
```rs
let mut sum = 1;

sum = 2;
// ok
```
2. 声明常量
- 除了声明变量，我们还可以声明一个常量。常量在绑定值以后也是不可变的，但它与不可变的变量是有区别的
- 常量不可使用 mut 关键字，常量永远是不可变的。并且 const 的初始化无类型推导，强迫开发者手动加类型注释(标注)。而且const后面必须是常量，初始化时的值是永远确定的
- 常量可以在任何作用域内进行声明，包括全局作用域。另外，常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
- 在程序运行期间，常量在其声明的作用域内一直有效
- 命名规范：rust 中常量使用全大写字母，每个单词之间用下划线分开
```rs
const MAX_POINTS: u32 = 100_100;

use std::io;

fn main () {
  const MAX_POINTS:i32 = 100;
  println!('{}',MAX_POINTS);
}
```

3. shadowing(遮蔽)
- 在 rust 中，可以使用相同的名字声明新的变量，新的变量就会 shadow(遮蔽) 之前声明的同名变量，在后续的代码中这个变量名代表的就是新的变量
- 并且，shadow 和把变量标记成 mut 是不一样的。如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译时错误；且使用 let 声明的同名新变量，也是不可变的，但它的类型可以与之前不同
---
## 数据类型
---
1. 静态类型
- rust 是静态编译语言，在编译时必须知道所有变量的类型。在大部分情况下，基于使用的值，编辑器通常能够推断出它的具体类型
- 但是如果可能的类型比较多（如把 String 转化为整数的 parse 方法），就必须添加类型的标注，否则编译会报错
```rs
fn main() {
  let guess = "42".parse().except("Not a number");
  // consider giving `guess` an explicit type: `: _`
  println!("{}",guess);
}
```

```rs
fn main() {
  let guess:u32 = "42".parse().except("Not a number");

  println!("{}",guess);
}
```
2. 标量类型
- 一个标量类型代表一个单个的值。rust 有四个主要的标量类型：`整数类型`、`浮点类型`、`布尔类型`、`字符类型`
3. 整数类型
- 没有小数部分。例如 u32 就是一个无符号(表示没有正负号)的整数类型，占据 32 位的空间，它的范围是 0 - 2^32-1（边界也包含在内）
- 无符号整数类型以 u 开头，有符号整数类型以 i 开头。每种都分 i 和 u，以及固定的位数。有符号的范围是 -(2^n - 1) 到 2^n - 1，无范围的范围是 0 到 2^n - 1，它们均包括两端

|Length|Signed|Unsigned|
|---|---|---|
|8-bit|i8|u8|
|16-bit|i16|u16|
|32-bit|i32|u32|
|64-bit|i64|u64|
|128-bit|i128|u128|
|arch|isize|usize|

- 而 isize 和 usize 的位数由程序运行的计算机的架构所决定，如果是 64 位的计算机，那就是 i64 和 u64；使用它的场景主要是对某种集合进行索引操作
- 整数字面值：加下划线可以用于加强可读性。除了 byte 类型以外，所有的数值字面值都允许使用类型后缀。

```rs
// 其中 u8 是类型标注，
let number1 = 57u8;
    // let number1:u8 = 57u8;
```

|Number literals|Example|
|---|---|
|Decimal|98_222|
|Hex|0xff|
|Octal|0o77|
|Binary|0b1111_0000|
|Byte(u8 only)|b'A'|

- 如果你不太确定使用那种类型，可以使用 rust 相应的默认类型：整数是 i32，总体来说速度非常快，即使是在 64 位系统中
- 整数溢出：例如 u8 的范围是 0-255，如果你把一个 u8 变量的值设为 256，一：在调试模式下编译：rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic(恐慌)；二：在发布模式下(--release)编译，rust 不会检查可能导致 panic 的整数溢出，如果溢出发生：rust 会执行“环绕”操作（256 变成 0，257 变成 1，依此类推），但不会导致程序 panic

4. 浮点类型
- rust 有两种基础的浮点类型，浮点类型指含有小数部分的类型，它使用了 IEEE-754 标准来描述。`f32`: 占据32位，单精度浮点类型；`f64`: 占据64位，双精度浮点类型
- f64 是默认类型，因为在现代 cpu 上 f64 和 f32 的速度差不多，而且精度更高

```rs
let f1 = 2.0;
// 默认类型 f64
let f2:f32 = 2.0;
```
- 需要注意的是，不同类型的值不能进行加减乘除，例如 f32 与 f64、i32 与 f32 等

5. 布尔类型
- 布尔类型有两个值，ture 和 false，类型符号是 bool，占据一个字节的大小

6. 字符类型
- rust 使用 char 类型来描述语言中最基础的单个字符，字符类型的字面值使用单引号，一个字符占据 4 字节大小。
- 它是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符。emoji 表情等，范围从 U+0000 到 U+D7FF，以及 U+E000 到 U+10FFFF
- 但是 Unicode 中并没有字符的概念，所以直觉上认为的字符与 rust 中的概念并不相符

7. tuple(元组)
- 复合类型可以将多个值放在一个类型里，rust 提供了两种基础的复合类型：元组（tuple）、数组
- 可以将多个类型的多个值放在一个类型里，tuple 的长度是固定的，一旦声明就无法改变。tuple 中的每个位置对应一个类型，tuple 中各元素的类型不必相同

```rs
let tuple1:(i32,char,bool) = (12,'a',true);
println!("{},{},{}",tuple1.0,tuple1.1,tuple.2);
```

- 使用点标记法接元素的索引号，可以访问 tuple 中的元素。获取 tuple 中的元素可以使用模式匹配来解构一个 tuple 来获取元素的值
```rs
let tuple1:(i32,char,bool) = (12,'a',true);
let (x,y,z) = tuple1;
```

8. 数组
- 数组也可以将多个值放在一个类型里，但是数组中每个元素的类型必须相同，数组的长度也是固定的，声明之后不能被改变
```rs
let arr1 = [1,1,2,111];
let arr2 = ["one","two","three","four"];
```

- 如果你想让你的数据存放在 stack(栈) 上而不是 heap(堆) 上，或者想保证有固定数量的元素，这时使用数组更有好处。另外一点的是，数组没有 Vector 灵活，它两是类似的，只不过 Vector 由标准库提供，数组由 prelude(预导入模块) 提供；Vector 的长度是可以改变的，当你不确定是用数组还是 Vector 时，那么估计你应该用 Vector
- 数组的类型如果要指定的话，可以以 [类型;长度] 的形式表示。另外，如果数组的每个元素值都相同，可以以 [值;长度] 的形式表示
```rs
let arr:[char;6] = ['a','b','c','d','e','f'];
let arr1:[i32;4] = [1,2,3,4];

let arr2 = [4;5];
// let arr2 = [4,4,4,4,4];
```
- 数组是 Stack 上分配的单个块的内存，我们可以使用索引来访问数组的元素
```rs
let arr2 = [4;5];
// let arr2 = [4,4,4,4,4];
let arr2_1 = arr2[0];
```
- 当访问的索引超出了数组的范围，那么：编译会通过，只会进行简单的检查，复杂情况会通过；但运行时会报错（runtime 时会 panic），rust 不会允许其继续访问相应地址的内存

```rs
let arr:[char;6] = ['a','b','c','d','e','f'];
let arr1 = [6,7,8,9];

let arr_out = arr[6];
// 编译、运行均报错

let arr_out2 = arr[arr1[0]];
// 编译时通过，运行时报错
```