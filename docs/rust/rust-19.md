---
title: 生命周期
date: 2023-06-27 02:02:15
categories: Rust
order: 20
tags:
  - Rust
  - 生命周期
---

## 生命周期
---
1. 描述
- 在 rust 里面，每个引用都有自己的生命周期，生命周期就是 **让引用保持有效的作用域**。而在大多数情况下，生命周期是隐式的、可被推断的，而当引用的生命周期可能以不同的方式互相关联时，就需要手动标注生命周期
- 生命周期存在的目的就是为了避免悬垂引用

2. 借用检查器
- rust 编译的借用检查器，是用来比较作用域从而来判断所有的借用是否合法

```rs
fn main () {
  {
    let r;            // -------------+-- 'a
                      //              /
    {                 //              /
      let x = 5;      // -+-- 'b --   /
      r = &x;         //              /
    }                 // -+--------   /
    println!("r: {}",r); //           /
  }                   //--------- + 
}
```

- 上述的代码中，rust 的编译器在编译的时候，它会比较这两个生命周期的长短。它发现 r 的生命周期是 a 这么长，但它却指向了一个生命周期为 b 的一块内存；此时因为 b 的生命周期比 a 短，所以编译就不会通过
- 那如何解决这个问题呢？那就是要 x 的生命周期 b 至少要不小于 a 的生命周期，简单来说，被引用的数据的存活时间，必须比引用者的长

```rs
fn main () {
  let x = 5;
  let r = &x; 
  println!("r: {}",r);
}
```

- 这样我们就知道了 rust 是如何通过分析生命周期来确定引用的合法性的

3. 函数中的泛型生命周期
- 目的是为了将返回值的生命周期和参数的生命周期关联起来

```rs
// x、y 的生命周期必须与泛型生命周期的存活时间一样长才行
fn longest<'a>(x:'a &str,y:'a &str) -> 'a &str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}
```
4. 生命周期的标注语法
- 生命周期的标注不会改变引用的生命周期长度，而且如果某函数指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用
- 实际上生命周期的标注描述了多个引用的生命周期间的关系，但不影响生命周期。但个生命周期标注本身没有意义

|写法|描述|
|---|---|
|&i32|一个引用|
|&'a i32|带有显式生命周期的引用｜
｜& 'a mut i32|带有显式生命周期的可变引用|

```rs
// 生命周期参数名：以 ' 开头，通常全小写且非常短，很多人使用 'a
fn main(){
  let str1 = String::from("abcd");
  let res;
  {
    let str2 = String::from("efg");
    res = longest(str1.as_str(),str2.as_str());
    // `str2` does not live long enough
  }
  println!("result is: {}",res);
}

// 这里的 'a 生命周期会取 x 或 y 这两个引用中其中比较短的那个(也就是 str2)
fn longest<'a>(x:&'a str,y:&'a str) -> &'a str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}
```

5. 深入理解生命周期
- 指定生命周期参数的方式往往取决于函数所做的事情。当函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期相匹配；如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值(**这就是悬垂引用，该值(函数内创建的值)在函数结束时就走出了作用域**)

```rs
// 生命周期参数名：以 ' 开头，通常全小写且非常短，很多人使用 'a
fn main(){
  let str1 = String::from("abcd");
  let str2 = String::from("efg");
  let res = longest(str1.as_str(),str2.as_str());
  println!("result is: {}",res);
}

// 这里的 'a 生命周期会取 x 或 y 这两个引用中其中比较短的那个(也就是 str2)
fn longest<'a>(x:&'a str,y:&str) -> &'a str {
  let res = String::from("abc");
  return res
  // cannot return reference to local variable `res`
}
```

- 在这里，当内部数据离开作用域时，longest 返回的引用依然指向了函数内部创建的内存，但此时内部的值早已在函数走出作用域时被清理掉了，这就发生了悬垂引用

```rs
fn main(){
  let str1 = String::from("abcd");
  let str2 = String::from("efg");
  let res = longest(str1.as_str(),str2.as_str());
  println!("result is: {}",res);
}

// 可以选择将所有权移交出来，这样就不会报错了
fn longest<'a>(x:&'a str,y:&str) -> String {
  let res = String::from("abc");
  return res
}
```

6. 生命周期省略规则
- 在 rust 引用分析中所编入的模式称为生命周期省略规则，这些规则无需开发者来遵守，它们是一些特殊情况，由编译器来考虑
- 如果你的代码符合这些情况，那么就无需显式标注生命周期；但规则不会提供完整的推断，如果引用规则后，引用的生命周期仍然模糊不清，就会导致编译错误，而解决办法就是显式添加生命周期，表明引用间的相互关系

7. 静态生命周期
- 'static 是一个特殊的生命周期，表示整个程序的持续时间。例如所有的字符串字面值都拥有 'static 生命周期
- 如果要为引用指定 'static 生命周期要三思，是否需要引用在程序整个生命周期内都存活