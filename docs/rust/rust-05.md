---
title: 所有权
date: 2023-04-14 16:40:44
categories: Rust
order: 6
tags:
  - Rust
  - 所有权
---

## 所有权
---
1. 描述
- 所有权是 rust 最独特的特性，它让 rust 无需 GC 就可以保证内存安全
- 它是 rust 的核心特性，所有程序在运行时都必须管理它们使用计算机内存的方式。有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存，将它们收集并释放；另一些语言中，程序的内存需要手动、显式地分配和释放内存
- rust 采用的是第三种方式。内存是通过一个所有权系统来管理的，其中包括一组编译器在编译时检查的规则，这种做法不会产生任何的运行时开销。也就是说，当程序运行时，所有权特性不会减慢程序的运行速度
- 这是因为 rust 把内存管理相关的工作都提前到了编译时

2. 栈内存与堆内存
- rust 这样的系统级编程语言中，一个值是在 stack 上还是在 heap 上对语言的行为和你为什么要做某些决定是有更大的影响的
- 在你的代码运行的时候，stack 和 heap 都是你可用的内存，但它们的结构很不相同

3. 存放数据的区别
- 按值的接收顺序来存储，按相反的顺序来将它们移除（先进先出，LIFO）。其中添加数据叫做压入栈，移除数据叫做弹出栈
- 所有存储在 stack 上的数据必须 *拥有已知的固定的大小*。编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 heap 上
- heap 对内存的组织性差一些。当你把数据放入 heap 时，你会请求一定数量的空间；操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址。这个过程叫做在 heap 上进行分配，有时仅仅称为 *分配*
- 但把值压到 stack 上不叫分配，因为它不需要分配，只需在 stack 内存中挨着放即可。因为指针是已知固定大小的，可以把指针存放到 stack 上；但是如果你想访问指针所指向的具体数据时，必须通过指针指向的地址来访问它
- 把数据压到 stack 上要比在 heap 上分配快得多，因为操作系统不需要寻找用来存储新数据的空间，这个位置永远在 stack 的顶端
- 而在 heap 上分配空间需要做更多的工作。操作系用首先要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配

4. 访问数据的区别
- 访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据。多了一个指针跳转的环节，它属于间接访问
- 对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快
- 如果数据存放的距离比较近，那么处理器的处理速度就会更快一些，例如放 stack 上。如果数据之间的距离比较远，那么处理速度就会慢一些，例如放 heap 上，而在 heap 上分配大量的空间也是需要时间的

5. 函数调用的区别
- 当你的代码调用函数时，值被传入到函数（也包括指向 heap 的指针）。函数本地的变量被压到 stack 上。当函数结束后，这些值会从 stack 上弹出

6. 所有权存在的原因
- 所有权解决的问题：跟踪代码中哪些部分正在使用 heap 中的哪些数据；最小化 heap 上的重复数据量；还可以清理 heap 上未使用的数据以避免空间不足
- 而当你懂了所有权后，就不需要经常去想 stack 或 heap 了。而管理 heap 数据是所有权存在的原因，这有助于解释它为什么这样工作